
var cdmi = require( '../lib/KBaseCDMI.js').KBaseCDMI;
var _    = require('underscore');

var kbaseapi = new cdmi();

var fid = 'kb|g.0.peg.1089';
//var fid = 'kb|df.0.peg.1089'; // With error
var fids = [fid];  

var callback = function(data) {
  console.dir(data);
};


var callback2 = function(data) {
  var first;
  console.dir(data);
  /********
  console.dir(data[0]);
  */
  for (first in data) break;

  //console.dir(_.first(data[first]));
  //console.dir(data[first]);
  //console.dir(_.flatten(data[first]));
  //console.dir(_.keys(_.object(data[first])));
  var fids2 = _.keys(_.object(data[first]));

  var res = kbaseapi.fids_to_feature_data(fids2, callback, errcallback);

};


var errcallback = function(errorCode) {
  console.log(errorCode);
};


/*
var res = kbaseapi.fids_to_literature(fids, callback, errcallback);
var res = kbaseapi.fids_to_annotations(fids, callback, errcallback);
var res = kbaseapi.fids_to_functions(fids, callback, errcallback);
var res = kbaseapi.fids_to_protein_families(fids, callback, errcallback);
var res = kbaseapi.fids_to_protein_sequences(fids, callback, errcallback);
var res = kbaseapi.fids_to_proteins(fids, callback, errcallback);
var res = kbaseapi.fids_to_roles(fids, callback, errcallback);
var res = kbaseapi.fids_to_subsystems(fids, callback, errcallback);
var res = kbaseapi.fids_to_locations(fids, callback, errcallback);
var res = kbaseapi.fids_to_coexpressed_fids(fids, callback, errcallback);
var res = kbaseapi.fids_to_atomic_regulons(fids, callback, errcallback);
var res = kbaseapi.fids_to_co_occurring_fids(fids, callback, errcallback);
var res = kbaseapi.fids_to_dna_sequences(fids, callback, errcallback);
var res = kbaseapi.fids_to_genomes(fids, callback, errcallback);
var res = kbaseapi.fids_to_subsystem_data(fids, callback, errcallback);
var res = kbaseapi.fids_to_regulon_data(fids, callback, errcallback);
var res = kbaseapi.fids_to_feature_data(fids, callback, errcallback);
*/


//var res = kbaseapi.fids_to_coexpressed_fids(fids, callback2, errcallback);


function getCoExpressed_old( fids ) {

  var res = kbaseapi.fids_to_coexpressed_fids([fids]
      , function( data ) {
          var first;
          //console.dir(data);
          for (first in data) break;

          var dataobjs = _.object(data[first]);
          console.dir(dataobjs);

          //console.dir(_.pick(dataobjs, 'kb|g.0.peg.2399'));



          var fids2 = _.keys(_.object(data[first]));

          var res = kbaseapi.fids_to_feature_data([fids2]
            , function(data2) {
              var i;
              //console.log(fids2);
              //console.log(fids2.length);

              for (i = 0; i < fids2.length; i++ ) {
                //console.log(fids2[i]);
                //console.dir(_.pick(dataobjs, fids2[i]));
                var currentValue = (_.values(_.pick(data2, fids2[i])))[0];
                console.log(currentValue);

                //console.dir(_.extend(_.values(_.pick(data2, fids2[i])), _.pick(dataobjs, fids2[i])));
              }

            }
            , function( errorCode2 ) { 
                console.log(errorCode);
          });

  
      }
      , function( errorCode ) {
          console.log(errorCode);
  });

}

function getCoExpressed( fids ) {

  var entireReturn = {};
  var returns = [];
  var res = kbaseapi.fids_to_coexpressed_fids([fids]
      , function( data ) {
          var first;
          var returnSize = 10;

          for (first in data) break;

          var dataobjs = _.object(data[first]);
          
          var allfids2 = _.keys(_.object(data[first]));
          entireReturn.count = allfids2.length;

          var fids2 = _.first(allfids2, returnSize);
          entireReturn.returned = fids2.length;
          entireReturn.data = returns;

          if (entireReturn.returned != 0 ) {

            var res = kbaseapi.fids_to_functions([fids2]
              , function(data2) {
                var i;
                for (i in data2 ) {
                  var obj = { 
                              id : i
                             ,function: data2[i]
                             ,pc : dataobjs[i]
                  };

                  returns.push(obj);

                }
                entireReturn.data = returns;
                console.log(entireReturn);
                //console.log(selfEntireReturn);

              }
              , function( errorCode2 ) { 
                  console.log(errorCode2);
            });
          } else {
            console.log(entireReturn);
          }

      }
      , function( errorCode ) {
          console.log(errorCode);
  });

}

function getAllCoExpressed( fids ) {

  var entireReturn = {};
  var returns = [];
  var res = kbaseapi.fids_to_coexpressed_fids([fids]
      , function( data ) {
          var first;
          var returnSize = 10;

          for (first in data) break;

          var dataobjs = _.object(data[first]);
          
          var allfids2 = _.keys(_.object(data[first]));
          entireReturn.count = allfids2.length;

          var fids2 = allfids2;
          entireReturn.returned = fids2.length;
          entireReturn.data = returns;

          if (entireReturn.returned != 0 ) {

            var res = kbaseapi.fids_to_functions([fids2]
              , function(data2) {
                var i;
                for (i in data2 ) {
                  var obj = { 
                              id : i
                             ,function: data2[i]
                             ,pc : dataobjs[i]
                  };

                  returns.push(obj);

                }
                entireReturn.data = returns;
                console.log(entireReturn);
                //console.log(selfEntireReturn);

              }
              , function( errorCode2 ) { 
                  console.log(errorCode2);
            });
          } else {
            console.log(entireReturn);
          }

      }
      , function( errorCode ) {
          console.log(errorCode);
  });

}

function getCooccurences( fids ) {

  var entireReturn = {};
  var returns = [];
  var res = kbaseapi.fids_to_co_occurring_fids([fids]
      , function( data ) {
          var first;
          var returnSize = 10;

          for (first in data) break;

          var dataobjs = _.object(data[first]);
          
          var allfids2 = _.keys(_.object(data[first]));
          entireReturn.count = allfids2.length;

          var fids2 = _.first(allfids2, returnSize);
          entireReturn.returned = fids2.length;
          entireReturn.data = returns;

          if (entireReturn.returned != 0 ) {

            var res = kbaseapi.fids_to_functions([fids2]
              , function(data2) {
                var i;
                for (i in data2 ) {
                  var obj = { 
                              id : i
                             ,function: data2[i]
                             ,occurences : dataobjs[i]
                  };

                  // NOTE: Did this to avoid adding all ids with empty feature entry
                  if ( obj.function.length != 0 ) {
                    returns.push(obj);
                  } else {
                    obj.function = "FUNCTION MISSING - Showing KBase Id instead: " + obj.id;
                    returns.push(obj);
                  }

                }
                entireReturn.data = returns;
                console.log(entireReturn);
                //console.log(selfEntireReturn);

              }
              , function( errorCode2 ) { 
                  console.log(errorCode2);
            });
          } else {
            console.log(entireReturn);
          }

      }
      , function( errorCode ) {
          console.log(errorCode);
  });

}

function getAllCooccurences( fids ) {

  var entireReturn = {};
  var returns = [];
  var res = kbaseapi.fids_to_co_occurring_fids([fids]
      , function( data ) {
          var first;
          var returnSize = 10;

          for (first in data) break;

          var dataobjs = _.object(data[first]);
          
          var allfids2 = _.keys(_.object(data[first]));
          entireReturn.count = allfids2.length;

          var fids2 = allfids2;
          entireReturn.returned = fids2.length;
          entireReturn.data = returns;

          if (entireReturn.returned != 0 ) {

            var res = kbaseapi.fids_to_functions([fids2]
              , function(data2) {
                var i;
                for (i in data2 ) {
                  var obj = { 
                              id : i
                             ,function: data2[i]
                             ,occurences : dataobjs[i]
                  };

                  // NOTE: Did this to avoid adding all ids with empty feature entry
                  if ( obj.function.length != 0 ) {
                    returns.push(obj);
                  } else {
                    obj.function = "FUNCTION MISSING - Showing KBase Id instead: " + obj.id;
                    returns.push(obj);
                  }

                }
                entireReturn.data = returns;
                console.log(entireReturn);
                //console.log(selfEntireReturn);

              }
              , function( errorCode2 ) { 
                  console.log(errorCode2);
            });
          } else {
            console.log(entireReturn);
          }

      }
      , function( errorCode ) {
          console.log(errorCode);
  });

}

/*
function getCooccurences( fids ) {

  var res = kbaseapi.fids_to_co_occurring_fids(fids
      , function( data ) {
          var first;
          var returns = [];
          var returnSize = 10;

          for (first in data) break;

          var dataobjs = _.object(data[first]);
          
          var allfids2 = _.keys(_.object(data[first]));
          var fids2 = _.first(allfids2, returnSize);

          console.log(fids2);

          var res = kbaseapi.fids_to_functions(fids2
            , function(data2) {
              console.log(data2);
              var i;
              for (i in data2 ) {
                var obj = { 
                            id : i
                           ,function: data2[i]
                           ,occurences : dataobjs[i]
                };

                // NOTE: Did this to avoid adding all ids with empty feature entry
                if ( obj.function.length != 0 ) {
                  returns.push(obj);
                } else {
                  obj.function = "FUNCTION MISSING - Showing KBase Id instead: " + obj.id;
                  returns.push(obj);
                }

              }
              console.dir(returns);

            }
            , function( errorCode2 ) { 
                console.log(errorCode2);
          });

  
      }
      , function( errorCode ) {
          console.log(errorCode);
  });

}
*/

function getFeatures( fids, type ) {

  var entireReturn = {};
  var returns = [];
  var res = kbaseapi.genomes_to_fids([fids,type]
      , function( data ) {
          var first;
          var returnSize = 10;
          for (first in data) break;

          var allfids2 = data[first];
          entireReturn.count = allfids2.length;

          var fids2 = _.first(allfids2, returnSize);
          entireReturn.returned = fids2.length;
          entireReturn.data = returns;

          if (entireReturn.returned != 0 ) {

            var res = kbaseapi.fids_to_functions([fids2]
              , function(data2) {
              //console.dir(data2);
                var i;
                for (i in data2 ) {
                  var obj = { 
                              id : i
                             ,function: data2[i]
                  };

                  // NOTE: Did this to avoid adding all ids with empty feature entry
                  if ( obj.function.length != 0 ) {
                    returns.push(obj);
                  } else {
                    obj.function = "FUNCTION MISSING - Showing KBase Id instead: " + obj.id;
                    returns.push(obj);
                  }

                }
                entireReturn.data = returns;

              }
              , function( errorCode2 ) { 
                  console.log(errorCode2);
            });
          } else {
            console.log(entireReturn);
          }

      }
      , function( errorCode ) {
          console.log(errorCode);
  });

}

function getContigs( fids ) {

  var entireReturn = {};
  var returns = [];
  var res = kbaseapi.genomes_to_contigs([fids]
      , function( data ) {
          var first;
          var returnSize = 10;

          for (first in data) break;

          var allfids2 = data[first];
          entireReturn.count = allfids2.length;

          var fids2 = _.first(allfids2, returnSize);
          entireReturn.returned = fids2.length;
          entireReturn.data = returns;

          if (entireReturn.returned != 0 ) {

            var res = kbaseapi.fids_to_functions([fids2]
              , function(data2) {
                var i;
                for (i in data2 ) {
                  var obj = { 
                              id : i
                             ,function: 'KBase Contig ID: ' + i
                  };

                  // NOTE: Did this to avoid adding all ids with empty feature entry
                  if ( obj.function.length != 0 ) {
                    returns.push(obj);
                  } else {
                    obj.function = "FUNCTION MISSING - Showing KBase Id instead: " + obj.id;
                    returns.push(obj);
                  }

                }
                entireReturn.data = returns;
                console.dir( entireReturn);

              }
              , function( errorCode2 ) { 
                  console.log(errorCode2);
            });
          } else {
            console.log(entireReturn);
          }

      }
      , function( errorCode ) {
          console.log(errorCode);
  });

}

//getCoExpressed( fids );
//getAllCoExpressed( fids );
//getCooccurences( fids );
//getAllCooccurences( fids );


/*
// Test for Function
var fid = 'kb|g.3223';
var fids = [fid];
var ftypes = ['CDS'];
getFeatures( fids, ftypes);
*/

// Test for Contigs
var fid = 'kb|g.3223';
var fid = 'kb|g.0';
var fids = [fid];
getContigs( fids );
